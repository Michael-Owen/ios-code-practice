# 序言：论述webapp和native app之争 #


# web开发，js,html5,css3 #
全文贯穿原生js和jQuery解释。只提供要点，具体细节请读者自己探索


## 先说JavaScript

JavaScript让人又爱又恨， 因为它独特， 卓越， 而且不可或缺。 尽管如此， 要说JavaScript很美， 恐怕也有些勉强。 JavaScript现在如日中天， 未来发展更是不可小觑。 但毕竟它的设计非常仓促1, 有些陷阱2, 有些晦涩3; 要不为啥Douglas Crockford的书名字叫《The Good Parts of JavaScript》呢? (题外话: 中文翻译叫"JavaScript语言精粹", 这实在是春秋笔法, 为圣者讳:D) 
所以, 要是中肯的评价JavaScript: “就是不美”. 

JavaScript为什么不美,我觉得amix讲的很清楚: 

- JavaScript是函数式语言;
- 是基于prototype实现的面向对象语言;
- 是动态语言, 更像Lisp而非C/Java; 但却使用了C/Java的语法;
- 名字里面叫Java, 其实和Java根本不搭边;

结论就是JavaScript的诞生是个悲剧. 它是函数式+动态语言的优秀内核, 却硬被绑上了C/Java的语法; 如同高分屏贴膜, 又如同剑宗人士非摆出气宗架势; 带有这种语法的JavaScript就如同包裹石头的璞玉5, 外壳和内涵大不相称. 
所以最大的别扭, 就在语法上.


## 关于div+css概述 ##
此处需要讲浏览器兼容性

我最早接触web开发是通过adobe Dreamweaver，它是一个可视化的所见即所得看法工具,所见即所得说白了就是拖拖,
	Insert sss.png
	
这东西特别简单，适合初学者，越是定制的东西它就显得不那么灵活，大多数人使用布局都是table来控制的，而且是table嵌入table，反复嵌套，导致代码可读性非常差，难于维护。所以div+css方式开始变得流行。
实际上东西还是那些东西，只不过布局处理都用div来处理，div的位置由css控制，废弃的table只用于它最常用的功能，比如表单布局和数据显示。

纯的html和css只能做静态效果。
因为那些年：
* css3还有出生，css还没有动画功能
* js还是一个高级的东西（那时候还不懂dom）

那些年的动态网页：
* 动态修改页面内容，比如自动播放n张图片
* 动态获取内容，增加fade,slide之类的效果

随着应用开发越来越强大和时代进步，浏览器兼容性问题尤其突出。万恶的ie让所有前端开发人员都痛苦不已，苦逼的岁月被ie糟蹋了

为啥ie是万恶的呢？
* 它的js机制和其他浏览器不一样，事件模型不一样
* 它对css解析不一样，经常需要单独处理。
* 它太嚣张了，使用率太高，而微软又固执的不愿修改


## 基本元素 ##
html语言是markup语言，这种语言的特点是格式固定，比如有<html>就必然有</html>对应

看一个简单的hello world吧

	<html>
		<head>
			<title>看一个简单的hello world吧</title>
		</head>
		<body>
			<div>hello world,俗吧</div>	
		</body>
	</html>
	
用浏览器打开它，看到是乱码？这是为什么呢？答案是因为里面有中文字符。所以修改一下

	<html>
		<head>
			<meta http-equiv="content-type" content="text/html;charset=utf-8">
			<title>看一个简单的hello world吧</title>
		</head>
		<body>
			<div>hello world,俗吧</div>	
		</body>
	</html>

看看dw里的可以拖拽的控件吧

@see component.html

## 多页跳转 ##
我们知道网站是由多个页面组成的，而页面直接通过跳转完成交互。页面跳转有3种方式：

1）表单提交

<form action='no320.com/formrequest.do' method='get'>
	<input type="text" name='testfield' vaslue="i'm the input text" placeholder='我是占位的input text'/>
	<input type='submit' value='提交'>
</form>

2）超链接
<a href='no320.com' target='_blank'>no320.com</a>

3）js方法

window.location.href='no320.com';

看一下例子代码

	<html>
		<head>
			<meta http-equiv="content-type" content="text/html;charset=utf-8">
			<title>多页跳转</title>
		</head>
		<body>
			<h1>多页跳转</h1>
			<h2>1）表单提交</h2>
		
				<form action='no320.com/formrequest.do' method='get'>
					<input type="text" name='testfield' vaslue="i'm the input text" placeholder='我是占位的input text'/>
					<input type='submit' value='提交'>
				</form>
		
			<h2>2）超链接</h2>
		
				<a href='no320.com' target='_self'>no320.com</a> || 
				<a href='no320.com' target='_blank'>no320.com</a> || 
				<a href='no320.com' target='_parent'>no320.com</a>
		
			<h2>3）js方法</h2>
				
				window.location.href='no320.com';
				<input type='button' value='点击跳转' onclick='jsClickToPage();'>
				
		</body>
		<script type='text/javascript'>
			function jsClickToPage(){	
				alert('正在跳转到no320.com');
				window.location.href='no320.com';
			}
		</script>
	</html>


## 表单 ##
这里只是演示了跳转方式，那么页面之间如何传递消息呢？我们先了解一下表单是什么。

表单是一种用于数据传递的形式。举个简单的例子，用户登陆，把某种商品放到购物车，这些操作都是通过表单提交来实现的。
看一下登陆的例子:

	<form action='no320.com/formrequest.do' method='get'>
		<input type="text" name='testfield' vaslue="i'm the input text" placeholder='请输入用户名'/>
		<input type="password" name='testfield' vaslue="i'm the input text" placeholder='请输入密码'/>
		<input type='submit' value='提交'>
	</form>

它的格式是<form action='$1' method='$2' multy='$3'/>
说明：
* $1 是表单要提交到后台的地址，此地址可以处理表单请求
* $2 是表单提交方法，一般是get和post。
* $3 如果表单有附件上传，需要支持多部头信息
表单提交：<input type='submit' value='提交'>

常用表单控件：
select
input {text|button|submit|reset|hidden}
textarea
label

## js和html交互（dom操作） ##
比如表单校验，已前面的例子为例：如果用户输入密码少于6个字母不允许登录




## 关于事件模型 ##

## post和get ##



## ajax使用 ##
以前的交互方式都是页面之间跳转或iframe来完成数据交互的。那么能不能不页面刷新就完成这样的功能交互呢？答案是ajax



给出个简单的例子，我想在页面里加载No320.ajax.js文件，并在ajaxDiv中显示

	var xhr;
	function testAjax() {
	    var url = "No320.ajax.js";
	    xhr = new XMLHttpRequest();
	    xhr.open("POST", url, true);
	    xhr.onreadystatechange = callback;
	    xhr.send(null);
	}

	function callback() {
	  	if(xhr.readyState == 4 && (xhr.status == 200||xhr.status == 0) ) {		  
		      document.getElementById("ajaxDiv").innerHTML = xhr.responseText;
		}
	}
代码其实很简单。核心是XMLHttpRequest这个对象。
她有3个方法，open和send是常规方法，用于指定请求方式和发送请求，只open没有send的话相当于没有执行

另外还有一个onreadystatechange方法，此方法用于检测xhr的readyState属性变化的方法。此属性每次变化她都会调用一次。

xhr的readyState属性可选值：
	0：
	1：
	2：
	3：
	4：

所以我们看callback方法里，会根据readyState和status值来判断接下来我们要做的事情，以本例来讲就是xhr.responseText在ajaxDiv中显示出来。
至此，相信你已经了解什么ajax和她的大致原理了。

接下来我们看一下jQuery的方法
$.ajax
$.get
$.post
$.getJSON
$.script
$.load

原理其实也都是上面所讲的
比如，我们简化一下get方法，我们希望

	$.get("No320.ajax.js",function(respText){
		 //alert(respText);
		 document.getElementById("ajaxGetDiv").innerHTML = respText;
	});
	
如何来实现呢？

给出改进后的No320.ajax.js代码：
	/*类机制定义*/
	window.Class = function(name, src) {
	    src.constructor.prototype = src;
	    window[name] = src.constructor;
	};

	/*No320Ajax类*/
	Class("No320Ajax", {
		constructor: function() {
			xhr=new XMLHttpRequest();
			cb=function(){};
			return this;
		},
		get:function(url,callback){
			cb=callback;
			this.__ajax(url,"GET");
		},
		post:function(url,callback){
			cb=callback;
			this.__ajax(url,"POST");
		},
		__ajax:function(url,type) {
		    xhr.open(type, url, true);
		    xhr.onreadystatechange = this.__callback;
		    xhr.send(null);
		},
		__callback:function(){
			//alert(xhr.responseText);
			if(xhr.readyState == 4 && (xhr.status == 200||xhr.status == 0) ) {
				cb(xhr.responseText);    
			}
		}
	})

看一下测试方法

	//def alias
	window.$ = new No320Ajax();

	//test
	//TODO:实现请求队列
	function testAjax() {
		$.get("No320.ajax.js",function(respText){
			 //alert(respText);
			 document.getElementById("ajaxGetDiv").innerHTML = respText;
		});
	
		setTimeout(function(){
			$.post("No320.ajax.js",function(respText){
				//alert("post"+respText);
				document.getElementById("ajaxPostDiv").innerHTML = respText;
			});
		},2000);
	}

另外我们可以看一下coffee-script/browser.js里的load实现：

CoffeeScript.load = function(url, callback) {
  var xhr;
  xhr = new (window.ActiveXObject || XMLHttpRequest)('Microsoft.XMLHTTP');
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) {
    xhr.overrideMimeType('text/plain');
  }
  xhr.onreadystatechange = function() {
    var _ref;
    if (xhr.readyState === 4) {
      if ((_ref = xhr.status) === 0 || _ref === 200) {
        CoffeeScript.run(xhr.responseText);
      } else {
        throw new Error("Could not load " + url);
      }
      if (callback) {
        return callback();
      }
    }
  };
  return xhr.send(null);
};

这里唯一的就是设置了MimeType。

还可以设置头部信息，比如gzip压缩等。












## json和jsonp,xml举例 ##

## 如何使用css修改显示样式 ##

## 理解css盒子模型 ##

## 理解css sprite ##

## 开发与调试工具 ##

## js测试与压缩 ##

## js oo ##



## 什么是迷你类库

最近，随着移动发展徐素，出现了一种轻量级的类库。


## 关于雅虎36条军规 ## 

